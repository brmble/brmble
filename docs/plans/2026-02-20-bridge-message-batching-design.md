# Bridge Message Batching Design

**Issue:** #28 — GUI updates lag behind server state changes
**Date:** 2026-02-20
**Priority focus:** Channel switch latency (then connect flow as a bonus)

## Problem

When the Mumble server confirms a state change (channel switch, user join/leave), the
MumbleAdapter fires multiple bridge messages to the frontend. Each message is a separate
`PostWebMessageAsJson` IPC call through the Win32 message pump. A single channel switch
produces up to 7 messages — each one serialized, enqueued, posted via `WM_USER`, dequeued,
and sent across the WebView2 process boundary individually.

The server roundtrip is fast (<20-100ms). The overhead is in the bridge pipeline:
`PostWebMessageAsJson` costs 1-5ms per call (cross-process IPC), and 7 calls interleaved
with other Win32 messages adds up to 7-35ms+ of avoidable delay.

## Solution

Batch bridge messages into a single IPC call per server packet.

### How it works

1. `NativeBridge.Send()` enqueues JSON but no longer posts `WM_USER` itself.
2. The MumbleAdapter process loop posts one `WM_USER` after each `Connection.Process()`
   call returns. All messages generated by that server packet are already in the queue.
3. `ProcessUiMessage()` drains the queue into a single JSON array and makes one
   `PostWebMessageAsJson` call. For single-message batches, the array wrapper is skipped.
4. `bridge.ts` detects arrays vs plain objects and dispatches each message in sequence
   within a single synchronous pass — React batches the state updates into one render.

### UI-thread-originated messages

Actions like mute toggle and disconnect are called from WndProc handlers (already on the
UI thread). These call `Send()` to enqueue, then `Flush()` to drain immediately — no
`WM_USER` roundtrip needed.

## Files changed

| File | Change |
|---|---|
| `NativeBridge.cs` | `Send()` enqueues only. `ProcessUiMessage()` builds JSON array. New `Flush()` method. |
| `MumbleAdapter.cs` | `ProcessLoop()` posts `WM_USER` after `Process()`. UI-thread handlers call `Flush()`. |
| `bridge.ts` | `_handleMessage()` handles both array and single-object payloads. |

## Edge cases

- **Empty queue on WM_USER:** `ProcessUiMessage()` returns without IPC call. Harmless.
- **Single message:** Sent as plain object (no array wrapper). Zero overhead for common case.
- **Connect burst:** Dozens of `ChannelState`/`UserState` messages batch per `Process()` call,
  reducing 30+ IPC calls to 5-6 batched calls.

## Verification

1. `dotnet build` succeeds
2. `dotnet test` passes
3. Manual: connect to server, switch channels — UI updates without visible lag
4. Manual: toggle mute/deafen — instant feedback
